# BaiduAI_Car
 第十九届智能车模型组

## 透视变换(mapping.cpp)

- 类 `Mapping` 定义了图像透视变换的方法和属性。
- 构造函数 `Mapping` 初始化了类的一些成员变量，包括原始图像大小 (`m_origSize`)、目标图像大小 (`m_dstSize`)、原始域的四个关键点 (`m_origPoints`) 和矫正域的四个关键点 (`m_dstPoints`)。同时计算了透视变换矩阵 `m_H` 和其逆矩阵 `m_H_inv`，并调用 `createMaps` 方法创建了变换后的图像坐标映射。
- `homographyInv` 方法用于将原始域的图像或坐标进行逆透视变换，其中调用了 `remap` 函数来实现图像的重映射。
- `homography` 方法用于将原始域的坐标进行透视变换。
- `drawBorder` 方法用于在图像上绘制掩膜外框，以便在可视化中显示变换区域。
- `createMaps` 方法用于创建图像坐标映射，通过遍历目标图像的每个像素，利用透视变换矩阵将目标图像的坐标映射到原始图像上，并生成映射矩阵 `m_mapX` 和 `m_mapY`。

## 预处理(preprocess.cpp)

**preprocess**类

方法:

- 通过从 XML 文件中读取来初始化相机标定参数

- `binaryzation` 方法：将输入的彩色图像转换为灰度图像，然后使用 Otsu 的阈值法进行二值化处理。

- `correction` 方法：根据相机标定参数对输入的图像进行畸变矫正，如果标定参数可用的话。它首先检查是否启用了标定。如果启用了，它会初始化图像矫正所需的矩阵，然后进行重映射

## 识别元素(recognition)

### 赛道线识别(tracking.cpp)

1. 在二值化后的图像上进行赛道识别，我们的做法是搜索图像中颜色突变的 点，然后将两个点之间做差求斜率，将这一张图片内的所有突变点斜率都计算 出来，进行三阶的贝塞尔拟合，进而得到精确的赛道类型（左转、右转等）。 在精确拟合赛道左右边线后，对对应点求中点，得出点的集合即为赛道中 线，赛道中线与相机视场中线的差值的绝对值就是修正值。

2. 八邻域边缘追踪算法
3. 主体巡线采用骨架提取与补线相互辅助
4. 在二值化之后的图像仅有黑白两个色块，因此赛道边缘的特征十分的明显，即在边缘 处存在黑白跳变，这样我们就可以把赛道边缘提取出来。本次比赛我们为了减小运算量而 没有采取遍历整张图片的方式，而是利用边线是连续的的特征，可以根据上一行的边界所 在的位置近似确定下一行边线的位置，这样可以快速找到两条边线。再用两条边线拟合出 中线，通过中线求出目前小车偏离中线的误差，再以此误差作为舵机 PID 控制器的输入， 以此控制小车的姿态







### 十字路口(crossroad.cpp)





## 2024/2/29

已经初步将硬件主板和驱动板完成


## 2024/3/5

config edgeboard ssh and git 





